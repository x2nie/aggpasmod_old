unit AggPlatformSupport;

// ----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4 (Public License)
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
// Copyright (C) 2003 Hansruedi Baer (MacOS support)
//
// Anti-Grain Geometry - Version 2.4 Release Milano 3 (AggPas 2.4 RM3)
// Pascal Port By: Milan Marusinec alias Milano
// milan@marusinec.sk
// http://www.aggpas.org
// Copyright (c) 2005-2006
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
// ----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
// mcseemagg@yahoo.com
// http://www.antigrain.com
// baer@karto.baug.eth.ch
//
// ----------------------------------------------------------------------------
//
// Note:
// I tried to retain the original structure for the Win32 platform as far
// as possible. Currently, not all features are implemented but the examples
// should work properly.
// HB
//
// ----------------------------------------------------------------------------
//
// class platform_support
//
// It's not a part of the AGG library, it's just a helper class to create
// interactive demo examples. Since the examples should not be too complex
// this class is provided to support some very basic interactive graphical
// funtionality, such as putting the rendered image to the window, simple
// keyboard and mouse input, window resizing, setting the window title,
// and catching the "idle" events.
//
// The most popular platforms are:
//
// Windows-32 API
// X-Window API
// SDL library (see http://www.libsdl.org/)
// MacOS C/C++ API
//
// All the system dependent stuff sits in the platform_specific class.
// The platform_support class has just a pointer to it and it's
// the responsibility of the implementation to create/delete it.
// This class being defined in the implementation file can have
// any platform dependent stuff such as HWND, X11 Window and so on.
//
// [Pascal Port History] -----------------------------------------------------
//
// 26.03.2006-Milano: Finished & tested MacOS X port
// 20.03.2006-Milano: Unit port establishment
//

interface

{$I agg_mode.inc}

uses
  Carbon,
  AggBasics,
  Agg_ctrl,
  Agg_rendering_buffer,
  Agg_trans_affine,
  Agg_trans_viewport,
  Agg_mac_pmap,
  AggColor_conv;


const
  // ----------------------------------------------------------window_flag_e
  // These are flags used in method init(). Not all of them are
  // applicable on different platforms, for example the win32_api
  // cannot use a hardware buffer (window_hw_buffer).
  // The implementation should simply ignore unsupported flags.
  wfResize = 1;
  Window_hw_buffer = 2;
  wfKeepAspectRatio = 4;
  wfProcessAllKeys = 8;

type
  // -----------------------------------------------------------pix_format_e
  // Possible formats of the rendering buffer. Initially I thought that it's
  // reasonable to create the buffer and the rendering functions in
  // accordance with the native pixel format of the system because it
  // would have no overhead for pixel format conersion.
  // But eventually I came to a conclusion that having a possibility to
  // convert pixel formats on demand is a good idea. First, it was X11 where
  // there lots of different formats and visuals and it would be great to
  // render everything in, say, RGB-24 and display it automatically without
  // any additional efforts. The second reason is to have a possibility to
  // debug renderers for different pixel formats and colorspaces having only
  // one computer and one system.
  //
  // This stuff is not included into the basic AGG functionality because the
  // number of supported pixel formats (and/or colorspaces) can be great and
  // if one needs to add new format it would be good only to add new
  // rendering files without having to modify any existing ones (a general
  // principle of incapsulation and isolation).
  //
  // Using a particular pixel format doesn't obligatory mean the necessity
  // of software conversion. For example, win32 API can natively display
  // gray8, 15-bit RGB, 24-bit BGR, and 32-bit BGRA formats.
  // This list can be (and will be!) extended in future.
  TPixelFormat = (
    pfUndefined, // By default. No conversions are applied
    pfbw, // 1 bit per color B/W
    pfGray8, // Simple 256 level grayscale
    pfGray16, // Simple 65535 level grayscale
    pf_Rgb555, // 15 bit rgb. Depends on the byte ordering!
    pf_Rgb565, // 16 bit rgb. Depends on the byte ordering!
    pf_RgbAAA, // 30 bit rgb. Depends on the byte ordering!
    pf_RgbBBA, // 32 bit rgb. Depends on the byte ordering!
    pfBgrAAA, // 30 bit bgr. Depends on the byte ordering!
    pfBgrABB, // 32 bit bgr. Depends on the byte ordering!
    pf_Rgb24, // R-G-B, one byte per color component
    pfBgr24, // B-G-R, native win32 BMP format.
    pf_Rgba32, // R-G-B-A, one byte per color component
    pfargb32, // A-R-G-B, native MAC format
    pfabgr32, // A-B-G-R, one byte per color component
    pfBgra32, // B-G-R-A, native win32 BMP format
    pf_Rgb48, // R-G-B, 16 bits per color component
    pfBgr48, // B-G-R, native win32 BMP format.
    pf_Rgba64, // R-G-B-A, 16 bits byte per color component
    pfArgb64, // A-R-G-B, native MAC format
    pfAbgr64, // A-B-G-R, one byte per color component
    pfBgra64, // B-G-R-A, native win32 BMP format

    End_of_pix_formats);

const
  // -------------------------------------------------------------input_flag_e
  // Mouse and keyboard flags. They can be different on different platforms
  // and the ways they are obtained are also different. But in any case
  // the system dependent flags should be mapped into these ones. The meaning
  // of that is as follows. For example, if kbd_ctrl is set it means that the
  // ctrl key is pressed and being held at the moment. They are also used in
  // the overridden methods such as on_mouse_move(), on_mouse_ButtonDown(),
  // on_mouse_button_dbl_click(), on_mouse_ButtonUp(), OnKey().
  // In the method on_mouse_ButtonUp() the mouse flags have different
  // meaning. They mean that the respective button is being released, but
  // the meaning of the keyboard flags remains the same.
  // There's absolut minimal set of flags is used because they'll be most
  // probably supported on different platforms. Even the mouse_right flag
  // is restricted because Mac's mice have only one button, but AFAIK
  // it can be simulated with holding a special key on the keydoard.
  Mouse_left = 1;
  Mouse_right = 2;
  Kbd_shift = 4;
  Kbd_ctrl = 8;

  // --------------------------------------------------------------key_code_e
  // Keyboard codes. There's also a restricted set of codes that are most
  // probably supported on different platforms. Any platform dependent codes
  // should be converted into these ones. There're only those codes are
  // defined that cannot be represented as printable ASCII-characters.
  // All printable ASCII-set can be used in a regilar C/C++ manner:
  // ' ', 'A', '0' '+' and so on.
  // Since the clasas is used for creating very simple demo-applications
  // we don't need very rich possibilities here, just basic ones.
  // Actually the numeric key codes are taken from the SDL library, so,
  // the implementation of the SDL support does not require any mapping.
  // ASCII set. Should be supported everywhere
  Key_backspace = 8;
  Key_tab = 9;
  Key_clear = 12;
  Key_return = 13;
  Key_pause = 19;
  Key_escape = 27;

  // Keypad
  Key_delete = 127;
  Key_kp0 = 256;
  Key_kp1 = 257;
  Key_kp2 = 258;
  Key_kp3 = 259;
  Key_kp4 = 260;
  Key_kp5 = 261;
  Key_kp6 = 262;
  Key_kp7 = 263;
  Key_kp8 = 264;
  Key_kp9 = 265;
  Key_kp_period = 266;
  Key_kp_divide = 267;
  Key_kp_multiply = 268;
  Key_kp_minus = 269;
  Key_kp_plus = 270;
  Key_kp_enter = 271;
  Key_kp_equals = 272;

  // Arrow-keys and stuff
  Key_up = 273;
  Key_down = 274;
  Key_right = 275;
  Key_left = 276;
  KeyInsert = 277;
  Key_home = 278;
  Key_end = 279;
  Key_page_up = 280;
  Key_page_down = 281;

  // Functional keys. You'd better avoid using
  // f11...f15 in your applications if you want
  // the applications to be portable
  Key_f1 = 282;
  Key_f2 = 283;
  Key_f3 = 284;
  Key_f4 = 285;
  Key_f5 = 286;
  Key_f6 = 287;
  Key_f7 = 288;
  Key_f8 = 289;
  Key_f9 = 290;
  Key_f10 = 291;
  Key_f11 = 292;
  Key_f12 = 293;
  Key_f13 = 294;
  Key_f14 = 295;
  Key_f15 = 296;

  // The possibility of using these keys is
  // very restricted. Actually it's guaranteed
  // only in win32_api and win32_sdl implementations
  Key_numlock = 300;
  Key_capslock = 301;
  Key_scrollock = 302;

  Max_ctrl = 128;

type
  // ----------------------------------------------------------ctrl_container
  // A helper class that contains pointers to a number of controls.
  // This class is used to ease the event handling with controls.
  // The implementation should simply call the appropriate methods
  // of this class when appropriate events occure.
  Crtl_container_ptr = ^Ctrl_container;

  Ctrl_container = object
  private
    FControls: array [0..Max_ctrl - 1] of PCtrlObject;

    FNumControls: Cardinal;
    FCurControl: Integer;
  public
    constructor Create;
    destructor Destruct;

    procedure Add(C: PCtrlObject);

    function InRect(X, Y: Double): Boolean;

    function OnMouseButtonDown(X, Y: Double): Boolean;
    function OnMouseButtonUp(X, Y: Double): Boolean;

    function OnMouseMove(X, Y: Double; Button_flag: Boolean): Boolean;
    function OnArrowKeys(Left, Right, Down, Up: Boolean): Boolean;

    function SetCurrent(X, Y: Double): Boolean;

  end;

  // ---------------------------------------------------------platform_support
  // This class is a base one to the apllication classes. It can be used
  // as follows:
  //
  // TheApplication = object(platform_support )
  //
  // constructor Create(bpp : Cardinal; flip_y : boolean );
  // . . .
  //
  // //override stuff . . .
  // procedure OnInit; virtual;
  // procedure OnDraw; virtual;
  // procedure OnResize(sx ,sy : int ); virtual;
  // // . . . and so on, see virtual functions
  //
  // //any your own stuff . . .
  // };
  //
  // VAR
  // app : TheApplication;
  //
  // BEGIN
  // app.Create(pix_formatRgb24 ,true );
  // app.caption  ("AGG Example. Lion" );
  //
  // if app.init(500 ,400 ,wfResize ) then
  // app.run;
  //
  // app.Destruct;
  //
  // END.
  //
const
  Max_images = 16;

type
  Platform_specific_ptr = ^Platform_specific;

  Platform_specific = object
  private
    FPixelFormat, FSystemPixelFormat: TPixelFormat;

    FFlipY: Boolean;
    FBitsPerPixel, FSystemBitsPerPixel: Cardinal;
    FWindow: WindowRef;

    FPixelMapWindow: Pixel_map;
    FPixelMapImage: array [0..Max_images - 1] of Pixel_map;

    FKeymap: array [0..255] of Cardinal;

    FLastTranslatedKey: Cardinal;

    FCurrentX, FCurrentY: Integer;

    FInputFlags: Cardinal;
    FRedrawFlag: Boolean;

    FSwFreq, FSwStart: CardinalWide;
  public
    constructor Create(Format: TPixelFormat; Flip_y: Boolean);
    destructor Destruct;

    procedure Create_pmap(Width, Height: Cardinal; Wnd: Rendering_buffer_ptr);
    procedure Display_pmap(Window: WindowRef; Src: Rendering_buffer_ptr);

    function Load_pmap(Fn: ShortString; Idx: Cardinal;
      Dst: Rendering_buffer_ptr): Boolean;
    function Save_pmap(Fn: ShortString; Idx: Cardinal;
      Src: Rendering_buffer_ptr): Boolean;

    function Translate(Keycode: Cardinal): Cardinal;

  end;

  Platform_support_ptr = ^Platform_support;

  Platform_support = object
  private
    FSpecific: Platform_specific_ptr;
    Controls: Ctrl_container;

    FPixelFormat: TPixelFormat;

    FBitsPerPixel: Cardinal;

    FRenderingBuffer_window: Rendering_buffer;
    FRenderingBuffer_img: array [0..Max_images - 1] of Rendering_buffer;

    FWindowFlags: Cardinal;
    FWaitMode, FFlipY: Boolean;
    // flip_y - true if you want to have the Y-axis flipped vertically
    FCaption: ShortString;
    FResizeMatrix: Trans_affine;

    FInitialWidth, FInitialHeight: Integer;
  public
    constructor Create(PixelFormat: TPixelFormat; FlipY: Boolean);
    destructor Destruct;

    // Setting the windows caption (title). Should be able
    // to be called at least before calling init().
    // It's perfect if they can be called anytime.
    procedure SetCaption(Cap: ShortString);

    // These 3 menthods handle working with images. The image
    // formats are the simplest ones, such as .BMP in Windows or
    // .ppm in Linux. In the applications the names of the files
    // should not have any file extensions. Method LoadImage() can
    // be called before init(), so, the application could be able
    // to determine the initial size of the window depending on
    // the size of the loaded image.
    // The argument "idx" is the number of the image 0...max_images-1
    function LoadImage(Idx: Cardinal; File_: ShortString): Boolean;
    function Save_img(Idx: Cardinal; File_: ShortString): Boolean;
    function CreateImage(Idx: Cardinal; Width_: Cardinal = 0;
      Height_: Cardinal = 0): Boolean;

    // init() and run(). See description before the class for details.
    // The necessity of calling init() after creation is that it's
    // impossible to call the overridden virtual function (OnInit())
    // from the constructor. On the other hand it's very useful to have
    // some OnInit() event handler when the window is created but
    // not yet displayed. The RbufWindow() method (see below) is
    // accessible from OnInit().
    function Init(Width_, Height_, Flags: Cardinal): Boolean;
    function Run: Integer;
    procedure Quit;

    // The very same parameters that were used in the constructor
    function _format: TPixelFormat;
    function _flip_y: Boolean;
    function _bpp: Cardinal;

    // The following provides a very simple mechanism of doing someting
    // in background. It's not multitheading. When whait_mode is true
    // the class waits for the events and it does not ever call OnIdle().
    // When it's false it calls OnIdle() when the event queue is empty.
    // The mode can be changed anytime. This mechanism is satisfactory
    // for creation very simple animations.
    function _wait_mode: Boolean;
    procedure SetWaitMode(Wait_mode: Boolean);

    // These two functions control updating of the window.
    // force_redraw() is an analog of the Win32 InvalidateRect() function.
    // Being called it sets a flag (or sends a message) which results
    // in calling OnDraw() and updating the content of the window
    // when the next event cycle comes.
    // update_window() results in just putting immediately the content
    // of the currently rendered buffer to the window without calling
    // OnDraw().
    procedure ForceRedraw;
    procedure UpdateWindow;

    // So, finally, how to draw anythig with AGG? Very simple.
    // RbufWindow() returns a reference to the main rendering
    // buffer which can be attached to any rendering class.
    // RbufImage() returns a reference to the previously created
    // or loaded image buffer (see LoadImage()). The image buffers
    // are not displayed directly, they should be copied to or
    // combined somehow with the RbufWindow(). RbufWindow() is
    // the only buffer that can be actually displayed.
    function RbufWindow: Rendering_buffer_ptr;
    function RbufImage(Idx: Cardinal): Rendering_buffer_ptr;

    // Returns file extension used in the implemenation for the particular
    // system.
    function _img_ext: ShortString;

    //
    procedure CopyImageToWindow(Idx: Cardinal);
    procedure CopyWindowToImage(Idx: Cardinal);
    procedure CopyImageToImage(Idx_to, Idx_from: Cardinal);

    // Event handlers. They are not pure functions, so you don't have
    // to override them all.
    // In my demo applications these functions are defined inside
    // the TheApplication class
    procedure OnInit; virtual;
    procedure OnResize(Sx, Sy: Integer); virtual;
    procedure OnIdle; virtual;

    procedure OnMouseMove(X, Y: Integer; Flags: Cardinal); virtual;

    procedure OnMouseButtonDown(X, Y: Integer; Flags: Cardinal); virtual;
    procedure OnMouseButtonUp(X, Y: Integer; Flags: Cardinal); virtual;

    procedure OnKey(X, Y: Integer; Key, Flags: Cardinal); virtual;
    procedure OnControlChange; virtual;
    procedure OnDraw; virtual;
    procedure OnPostDraw(Raw_handler: Pointer); virtual;

    // Adding control elements. A control element once added will be
    // working and reacting to the mouse and keyboard events. Still, you
    // will have to render them in the OnDraw() using function
    // RenderControl() because platform_support doesn't know anything about
    // renderers you use. The controls will be also scaled automatically
    // if they provide a proper scaling mechanism (all the controls
    // included into the basic AGG package do).
    // If you don't need a particular control to be scaled automatically
    // call ctrl::no_transform() after adding.
    procedure AddControl(C: PCtrlObject);

    // Auxiliary functions. trans_affine_resizing() modifier sets up the resizing
    // matrix on the basis of the given width and height and the initial
    // width and height of the window. The implementation should simply
    // call this function every time when it catches the resizing event
    // passing in the new values of width and height of the window.
    // Nothing prevents you from "cheating" the scaling matrix if you
    // call this function from somewhere with wrong arguments.
    // trans_affine_resizing() accessor simply returns current resizing matrix
    // which can be used to apply additional scaling of any of your
    // stuff when the window is being resized.
    // width(), height(), initial_width(), and initial_height() must be
    // clear to understand with no comments :-)
    procedure Trans_affine_resizing_(Width_, Height_: Integer);
    function GetTransAffineResizing: Trans_affine_ptr;

    function GetWidth: Double;
    function GetHeight: Double;
    function GetInitialWidth: Double;
    function GetInitialHeight: Double;
    function GetWindowFlags: Cardinal;

    // Get raw display handler depending on the system.
    // For win32 its an HDC, for other systems it can be a pointer to some
    // structure. See the implementation files for detals.
    // It's provided "as is", so, first you should check if it's not null.
    // If it's null the raw_display_handler is not supported. Also, there's
    // no guarantee that this function is implemented, so, in some
    // implementations you may have simply an unresolved symbol when linking.
    function GetRawDisplayHandler: Pointer;

    // display message box or print the message to the console
    // (depending on implementation)
    procedure DisplayMessage(Msg: PAnsiChar);

    // Stopwatch functions. Function GetElapsedTime() returns time elapsed
    // since the latest start_timer() invocation in millisecods.
    // The resolutoin depends on the implementation.
    // In Win32 it uses QueryPerformanceFrequency() / QueryPerformanceCounter().
    procedure StartTimer;
    function GetElapsedTime: Double;

    // Get the full file name. In most cases it simply returns
    // file_name. As it's appropriate in many systems if you open
    // a file by its name without specifying the path, it tries to
    // open it in the current directory. The demos usually expect
    // all the supplementary files to be placed in the current
    // directory, that is usually coincides with the directory where
    // the the executable is. However, in some systems (BeOS) it's not so.
    // For those kinds of systems FullFileName() can help access files
    // preserving commonly used policy.
    // So, it's a good idea to use in the demos the following:
    // FILE* fd = fopen(FullFileName("some.file"), "r");
    // instead of
    // FILE* fd = fopen("some.file", "r");
    function FullFileName(File_name: ShortString): ShortString;
    function File_source(Path, Fname: ShortString): ShortString;

  end;



implementation



{ CREATE }
constructor Ctrl_container.Create;
begin
  FNumControls := 0;
  FCurControl := -1;

end;

{ DESTRUCT }
destructor Ctrl_container.Destruct;
begin
end;

{ ADD }
procedure Ctrl_container.Add;
begin
  if FNumControls < Max_ctrl then
  begin
    FControls[FNumControls] := C;

    Inc(FNumControls);

  end;

end;

{ InRect }
function Ctrl_container.InRect;
var
  I: Cardinal;

begin
  Result := False;

  if FNumControls > 0 then
    for I := 0 to FNumControls - 1 do
      if FControls[I].InRect(X, Y) then
      begin
        Result := True;

        Exit;

      end;

end;

{ ON_MOUSE_ButtonDown }
function Ctrl_container.OnMouseButtonDown;
var
  I: Cardinal;

begin
  Result := False;

  if FNumControls > 0 then
    for I := 0 to FNumControls - 1 do
      if FControls[I].OnMouseButtonDown(X, Y) then
      begin
        Result := True;

        Exit;

      end;

end;

{ ON_MOUSE_ButtonUp }
function Ctrl_container.OnMouseButtonUp;
var
  I: Cardinal;

begin
  Result := False;

  if FNumControls > 0 then
    for I := 0 to FNumControls - 1 do
      if FControls[I].OnMouseButtonUp(X, Y) then
      begin
        Result := True;

        Exit;

      end;

end;

{ ON_MOUSE_MOVE }
function Ctrl_container.OnMouseMove;
var
  I: Cardinal;

begin
  Result := False;

  if FNumControls > 0 then
    for I := 0 to FNumControls - 1 do
      if FControls[I].OnMouseMove(X, Y, Button_flag) then
      begin
        Result := True;

        Exit;

      end;

end;

{ OnArrowKeys }
function Ctrl_container.OnArrowKeys;
begin
  Result := False;

  if FCurControl >= 0 then
    Result := FControls[FCurControl].OnArrowKeys(Left, Right, Down, Up);

end;

{ SetCurrent }
function Ctrl_container.SetCurrent;
var
  I: Cardinal;

begin
  Result := False;

  if FNumControls > 0 then
    for I := 0 to FNumControls - 1 do
      if FControls[I].InRect(X, Y) then
      begin
        if FCurControl <> I then
        begin
          FCurControl := I;

          Result := True;

        end;

        Exit;

      end;

  if FCurControl <> -1 then
  begin
    FCurControl := -1;

    Result := True;

  end;

end;

{ CREATE }
constructor Platform_specific.Create;
var
  I: Cardinal;

begin
  FPixelMapWindow.Create;

  for I := 0 to Max_images - 1 do
    FPixelMapImage[I].Create;

  FPixelFormat := Format;
  FSystemPixelFormat := pfUndefined;

  FFlipY := Flip_y;
  FBitsPerPixel := 0;
  FSystemBitsPerPixel := 0;
  FWindow := nil;

  FLastTranslatedKey := 0;

  FCurrentX := 0;
  FCurrentY := 0;

  FInputFlags := 0;
  FRedrawFlag := True;

  Fillchar(FKeymap[0], SizeOf(FKeymap), 0);

  // Keyboard input is not yet fully supported nor tested
  // FKeymap[VK_PAUSE ]:=key_pause;
  FKeymap[KClearCharCode] := Key_clear;

  // FKeymap[VK_NUMPAD0 ] :=key_kp0;
  // FKeymap[VK_NUMPAD1 ] :=key_kp1;
  // FKeymap[VK_NUMPAD2 ] :=key_kp2;
  // FKeymap[VK_NUMPAD3 ] :=key_kp3;
  // FKeymap[VK_NUMPAD4 ] :=key_kp4;
  // FKeymap[VK_NUMPAD5 ] :=key_kp5;
  // FKeymap[VK_NUMPAD6 ] :=key_kp6;
  // FKeymap[VK_NUMPAD7 ] :=key_kp7;
  // FKeymap[VK_NUMPAD8 ] :=key_kp8;
  // FKeymap[VK_NUMPAD9 ] :=key_kp9;
  // FKeymap[VK_DECIMAL ] :=key_kp_period;
  // FKeymap[VK_DIVIDE ]  :=key_kp_divide;
  // FKeymap[VK_MULTIPLY ]:=key_kp_multiply;
  // FKeymap[VK_SUBTRACT ]:=key_kp_minus;
  // FKeymap[VK_ADD ]     :=key_kp_plus;

  FKeymap[KUpArrowCharCode] := Key_up;
  FKeymap[KDownArrowCharCode] := Key_down;
  FKeymap[KRightArrowCharCode] := Key_right;
  FKeymap[KLeftArrowCharCode] := Key_left;
  // FKeymap[VK_INSERT ]:=keyInsert;
  FKeymap[KDeleteCharCode] := Key_delete;
  FKeymap[KHomeCharCode] := Key_home;
  FKeymap[KEndCharCode] := Key_end;
  FKeymap[KPageUpCharCode] := Key_page_up;
  FKeymap[KPageDownCharCode] := Key_page_down;

  // FKeymap[VK_F1 ] :=key_f1;
  // FKeymap[VK_F2 ] :=key_f2;
  // FKeymap[VK_F3 ] :=key_f3;
  // FKeymap[VK_F4 ] :=key_f4;
  // FKeymap[VK_F5 ] :=key_f5;
  // FKeymap[VK_F6 ] :=key_f6;
  // FKeymap[VK_F7 ] :=key_f7;
  // FKeymap[VK_F8 ] :=key_f8;
  // FKeymap[VK_F9 ] :=key_f9;
  // FKeymap[VK_F10 ]:=key_f10;
  // FKeymap[VK_F11 ]:=key_f11;
  // FKeymap[VK_F12 ]:=key_f12;
  // FKeymap[VK_F13 ]:=key_f13;
  // FKeymap[VK_F14 ]:=key_f14;
  // FKeymap[VK_F15 ]:=key_f15;

  // FKeymap[VK_NUMLOCK ]:=key_numlock;
  // FKeymap[VK_CAPITAL ]:=key_capslock;
  // FKeymap[VK_SCROLL ] :=key_scrollock;

  case FPixelFormat of
    pfGray8:
      begin
        FSystemPixelFormat := pf_Rgb24;
        FBitsPerPixel := 8;
        FSystemBitsPerPixel := 24;

      end;

    pf_Rgb565, pf_Rgb555:
      begin
        FSystemPixelFormat := pf_Rgb555;
        FBitsPerPixel := 16;
        FSystemBitsPerPixel := 16;

      end;

    pf_Rgb24, pfBgr24:
      begin
        FSystemPixelFormat := pf_Rgb24;
        FBitsPerPixel := 24;
        FSystemBitsPerPixel := 24;

      end;

    pfBgra32, pfabgr32, pfargb32, pf_Rgba32:
      begin
        FSystemPixelFormat := pfargb32;
        FBitsPerPixel := 32;
        FSystemBitsPerPixel := 32;

      end;

  end;

  Microseconds(FSwFreq);
  Microseconds(FSwStart);

end;

{ DESTRUCT }
destructor Platform_specific.Destruct;
var
  I: Cardinal;

begin
  FPixelMapWindow.Destruct;

  for I := 0 to Max_images - 1 do
    FPixelMapImage[I].Destruct;

end;

{ CREATE_PMAP }
procedure Platform_specific.Create_pmap;
begin
  FPixelMapWindow.Create(Width, Height, FBitsPerPixel);

  if FFlipY then
    Wnd.Attach(FPixelMapWindow.GetBuffer, FPixelMapWindow.GetWidth, FPixelMapWindow.GetHeight,
      -FPixelMapWindow._row_bytes)

  else
    Wnd.Attach(FPixelMapWindow.GetBuffer, FPixelMapWindow.GetWidth, FPixelMapWindow.GetHeight,
      FPixelMapWindow._row_bytes)

end;

{ convert_pmap }
procedure Convert_pmap(Dst, Src: Rendering_buffer_ptr; Format: TPixelFormat);
begin
  case Format of
    pfGray8:
      Color_conv(Dst, Src, Color_conv_gray8_toRgb24);

    pf_Rgb565:
      Color_conv(Dst, Src, Color_convRgb565_toRgb555);

    pfBgr24:
      Color_conv(Dst, Src, Color_conv_bgr24_toRgb24);

    pfabgr32:
      Color_conv(Dst, Src, Color_conv_abgr32_to_argb32);

    pfBgra32:
      Color_conv(Dst, Src, Color_conv_bgra32_to_argb32);

    pf_Rgba32:
      Color_conv(Dst, Src, Color_convRgba32_to_argb32);

  end;

end;

{ DISPLAY_PMAP }
procedure Platform_specific.Display_pmap;
var
  Pmap_tmp: Pixel_map;
  Rbuf_tmp: Rendering_buffer;

begin
  if FSystemPixelFormat = FPixelFormat then
    FPixelMapWindow.Draw(Window)

  else
  begin
    Pmap_tmp.Create;
    Pmap_tmp.Create(FPixelMapWindow.GetWidth, FPixelMapWindow.GetHeight, FSystemBitsPerPixel);

    Rbuf_tmp.Create;

    if FFlipY then
      Rbuf_tmp.Attach(Pmap_tmp.GetBuffer, Pmap_tmp.GetWidth, Pmap_tmp.GetHeight,
        -Pmap_tmp._row_bytes)
    else
      Rbuf_tmp.Attach(Pmap_tmp.GetBuffer, Pmap_tmp.GetWidth, Pmap_tmp.GetHeight,
        Pmap_tmp._row_bytes);

    Convert_pmap(@Rbuf_tmp, Src, FPixelFormat);
    Pmap_tmp.Draw(Window);

    Rbuf_tmp.Destruct;
    Pmap_tmp.Destruct;

  end;

end;

{ LOAD_PMAP }
function Platform_specific.Load_pmap;
var
  Pmap_tmp: Pixel_map;
  Rbuf_tmp: Rendering_buffer;

begin
  Pmap_tmp.Create;

  if not Pmap_tmp.Load_from_qt(Fn) then
  begin
    Result := False;

    Pmap_tmp.Destruct;
    Exit;

  end;

  Rbuf_tmp.Create;

  if FFlipY then
    Rbuf_tmp.Attach(Pmap_tmp.GetBuffer, Pmap_tmp.GetWidth, Pmap_tmp.GetHeight,
      -Pmap_tmp._row_bytes)
  else
    Rbuf_tmp.Attach(Pmap_tmp.GetBuffer, Pmap_tmp.GetWidth, Pmap_tmp.GetHeight,
      Pmap_tmp._row_bytes);

  FPixelMapImage[Idx].Create(Pmap_tmp.GetWidth, Pmap_tmp.GetHeight, FBitsPerPixel, 0);

  if FFlipY then
    Dst.Attach(FPixelMapImage[Idx].GetBuffer, FPixelMapImage[Idx].GetWidth,
      FPixelMapImage[Idx].GetHeight, -FPixelMapImage[Idx]._row_bytes)
  else
    Dst.Attach(FPixelMapImage[Idx].GetBuffer, FPixelMapImage[Idx].GetWidth,
      FPixelMapImage[Idx].GetHeight, FPixelMapImage[Idx]._row_bytes);

  case FPixelFormat of
    pf_Rgb555:
      case Pmap_tmp.GetBitsPerPixel of
        16:
          Color_conv(Dst, @Rbuf_tmp, Color_convRgb555_toRgb555);
        24:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgr24_toRgb555);
        32:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgra32_toRgb555);

      end;

    pf_Rgb565:
      case Pmap_tmp.GetBitsPerPixel of
        16:
          Color_conv(Dst, @Rbuf_tmp, Color_convRgb555_toRgb565);
        24:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgr24_toRgb565);
        32:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgra32_toRgb565);

      end;

    pf_Rgb24:
      case Pmap_tmp.GetBitsPerPixel of
        16:
          Color_conv(Dst, @Rbuf_tmp, Color_convRgb555_toRgb24);
        24:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgr24_toRgb24);
        32:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgra32_toRgb24);

      end;

    pfBgr24:
      case Pmap_tmp.GetBitsPerPixel of
        16:
          Color_conv(Dst, @Rbuf_tmp, Color_convRgb555_to_bgr24);
        24:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgr24_to_bgr24);
        32:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgra32_to_bgr24);

      end;

    pfabgr32:
      case Pmap_tmp.GetBitsPerPixel of
        16:
          Color_conv(Dst, @Rbuf_tmp, Color_convRgb555_to_abgr32);
        24:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgr24_to_abgr32);
        32:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgra32_to_abgr32);

      end;

    pfargb32:
      case Pmap_tmp.GetBitsPerPixel of
        16:
          Color_conv(Dst, @Rbuf_tmp, Color_convRgb555_to_argb32);
        24:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgr24_to_argb32);
        32:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgra32_to_argb32);

      end;

    pfBgra32:
      case Pmap_tmp.GetBitsPerPixel of
        16:
          Color_conv(Dst, @Rbuf_tmp, Color_convRgb555_to_bgra32);
        24:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgr24_to_bgra32);
        32:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgra32_to_bgra32);

      end;

    pf_Rgba32:
      case Pmap_tmp.GetBitsPerPixel of
        16:
          Color_conv(Dst, @Rbuf_tmp, Color_convRgb555_toRgba32);
        24:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgr24_toRgba32);
        32:
          Color_conv(Dst, @Rbuf_tmp, Color_conv_bgra32_toRgba32);

      end;

  end;

  Pmap_tmp.Destruct;
  Rbuf_tmp.Destruct;

  Result := True;

end;

{ SAVE_PMAP }
function Platform_specific.Save_pmap;
var
  Pmap_tmp: Pixel_map;
  Rbuf_tmp: Rendering_buffer;

begin
  if FSystemPixelFormat = FPixelFormat then
  begin
    Result := FPixelMapImage[Idx].Save_as_qt(Fn);

    Exit;

  end;

  Pmap_tmp.Create;
  Pmap_tmp.Create(FPixelMapImage[Idx].GetWidth, FPixelMapImage[Idx].GetHeight, FSystemBitsPerPixel);

  Rbuf_tmp.Create;

  if FFlipY then
    Rbuf_tmp.Attach(Pmap_tmp.GetBuffer, Pmap_tmp.GetWidth, Pmap_tmp.GetHeight,
      -Pmap_tmp._row_bytes)
  else
    Rbuf_tmp.Attach(Pmap_tmp.GetBuffer, Pmap_tmp.GetWidth, Pmap_tmp.GetHeight,
      Pmap_tmp._row_bytes);

  Convert_pmap(@Rbuf_tmp, Src, FPixelFormat);

  Result := Pmap_tmp.Save_as_qt(Fn);

  Rbuf_tmp.Destruct;
  Pmap_tmp.Destruct;

end;

{ TRANSLATE }
function Platform_specific.Translate;
begin
  if Keycode > 255 then
    FLastTranslatedKey := 0
  else
    FLastTranslatedKey := FKeymap[Keycode];

end;

{ CREATE }
constructor Platform_support.Create;
var
  I: Cardinal;

begin
  New(FSpecific, Create(Format_, FlipY));

  Controls.Create;
  FRenderingBuffer_window.Create;

  for I := 0 to Max_images - 1 do
    FRenderingBuffer_img[I].Create;

  FResizeMatrix.Create;

  FPixelFormat := Format_;

  FBitsPerPixel := FSpecific.FBitsPerPixel;

  FWindowFlags := 0;
  FWaitMode := True;
  FFlipY := FlipY;

  FInitialWidth := 10;
  FInitialHeight := 10;

  FCaption := 'Anti-Grain Geometry Application'#0;

end;

{ DESTRUCT }
destructor Platform_support.Destruct;
var
  I: Cardinal;

begin
  Dispose(FSpecific, Destruct);

  Controls.Destruct;
  FRenderingBuffer_window.Destruct;

  for I := 0 to Max_images - 1 do
    FRenderingBuffer_img[I].Destruct;

end;

{ CAPTION_ }
procedure Platform_support.SetCaption;
begin
  FCaption := Cap + #0;

  Dec(Byte(FCaption[0]));

  if FSpecific.FWindow <> nil then
    SetWindowTitleWithCFString(FSpecific.FWindow,
      CFStringCreateWithPascalStringNoCopy(nil, Cap,
      KCFStringEncodingASCII, nil));

end;

{ LOAD_IMG }
function Platform_support.Load_img;
begin
  if Idx < Max_images then
  begin
    File_ := File_ + _img_ext;
    Result := FSpecific.Load_pmap(File_, Idx, @FRenderingBuffer_img[Idx]);

  end
  else
    Result := True;

end;

{ SAVE_IMG }
function Platform_support.Save_img;
begin
  if Idx < Max_images then
    Result := FSpecific.Save_pmap(File_, Idx, @FRenderingBuffer_img[Idx])
  else
    Result := True;

end;

{ CREATE_IMG }
function Platform_support.Create_img;
begin
  if Idx < Max_images then
  begin
    if Width_ = 0 then
      Width_ := FSpecific.FPixelMapWindow.GetWidth;

    if Height_ = 0 then
      Height_ := FSpecific.FPixelMapWindow.GetHeight;

    FSpecific.FPixelMapImage[Idx].Create(Width_, Height_, FSpecific.FBitsPerPixel);

    if FFlipY then
      FRenderingBuffer_img[Idx].Attach(FSpecific.FPixelMapImage[Idx].GetBuffer,
        FSpecific.FPixelMapImage[Idx].GetWidth, FSpecific.FPixelMapImage[Idx].GetHeight,
        -FSpecific.FPixelMapImage[Idx]._row_bytes)
    else
      FRenderingBuffer_img[Idx].Attach(FSpecific.FPixelMapImage[Idx].GetBuffer,
        FSpecific.FPixelMapImage[Idx].GetWidth, FSpecific.FPixelMapImage[Idx].GetHeight,
        FSpecific.FPixelMapImage[Idx]._row_bytes);

    Result := True;

  end
  else
    Result := False;

end;

{ get_key_flags }
function Get_key_flags(Wflags: Integer): Cardinal;
var
  Flags: Cardinal;

begin
  Flags := 0;

  if Wflags and ShiftKey <> 0 then
    Flags := Flags or Kbd_shift;

  if Wflags and ControlKey <> 0 then
    Flags := Flags or Kbd_ctrl;

  Result := Flags;

end;

{ DOWINDOWCLOSE }
function DoWindowClose(NextHandler: EventHandlerCallRef; TheEvent: EventRef;
  UserData: Pointer): OSStatus;
begin
  QuitApplicationEventLoop;

  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOWINDOWDRAWCONTENT }
function DoWindowDrawContent(NextHandler: EventHandlerCallRef;
  TheEvent: EventRef; UserData: Pointer): OSStatus;
var
  App: Platform_support_ptr;

begin
  App := Platform_support_ptr(UserData);

  if App <> nil then
  begin
    if App.FSpecific.FRedrawFlag then
    begin
      App.OnDraw;

      App.FSpecific.FRedrawFlag := False;

    end;

    App.FSpecific.Display_pmap(App.FSpecific.FWindow, App.RbufWindow);

  end;

  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOWINDOWRESIZE }
function DoWindowResize(NextHandler: EventHandlerCallRef; TheEvent: EventRef;
  UserData: Pointer): OSStatus;
var
  App : Platform_support_ptr;
  Rect: Carbon.Rect;

  Width, Height: Cardinal;

begin
  App := Platform_support_ptr(UserData);

  GetWindowBounds(App.FSpecific.FWindow, KWindowContentRgn, Rect);

  Width := Rect.Right - Rect.Left;
  Height := Rect.Bottom - Rect.Top;

  if (Width <> App.RbufWindow.GetWidth) or (Height <> App.RbufWindow.GetHeight)
  then
  begin
    App.FSpecific.Create_pmap(Width, Height, App.RbufWindow);
    App.Trans_affine_resizing_(Width, Height);

    App.OnResize(Width, Height);

  end;

  App.ForceRedraw;

  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOAPPQUIT }
function DoAppQuit(NextHandler: EventHandlerCallRef; TheEvent: EventRef;
  UserData: Pointer): OSStatus;
begin
  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOMOUSEDOWN }
function DoMouseDown(NextHandler: EventHandlerCallRef; TheEvent: EventRef;
  UserData: Pointer): OSStatus;
var
  WheresMyMouse: Carbon.Point;

  Modifier: UInt32;
  Button  : EventMouseButton;

  Sz : UInt32;
  App: Platform_support_ptr;
  Ept: EventParamType;

begin
  Ept := 0;

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamMouseLocation[1])
    ^), LongWord(PInt32(@TypeQDPoint[1])^), Ept, SizeOf(Carbon.Point), Sz,
    @WheresMyMouse);

  GlobalToLocal(WheresMyMouse);
  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamKeyModifiers[1])^),
    LongWord(PInt32(@TypeUInt32[1])^), Ept, SizeOf(UInt32), Sz, @Modifier);

  App := Platform_support_ptr(UserData);

  App.FSpecific.FCurrentX := WheresMyMouse.H;

  if App._flip_y then
    App.FSpecific.FCurrentY := App.RbufWindow.GetHeight - WheresMyMouse.V
  else
    App.FSpecific.FCurrentY := WheresMyMouse.V;

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamMouseButton[1])^),
    LongWord(PInt32(@TypeMouseButton[1])^), Ept, SizeOf(EventMouseButton),
    Sz, @Button);

  case Button of
    KEventMouseButtonSecondary:
      App.FSpecific.FInputFlags := Mouse_right or Get_key_flags(Modifier);

  else
    App.FSpecific.FInputFlags := Mouse_left or Get_key_flags(Modifier);

  end;

  App.Controls.SetCurrent(App.FSpecific.FCurrentX, App.FSpecific.FCurrentY);

  if App.Controls.OnMouseButtonDown(App.FSpecific.FCurrentX,
    App.FSpecific.FCurrentY) then
  begin
    App.OnControlChange;
    App.ForceRedraw;

  end
  else if App.Controls.InRect(App.FSpecific.FCurrentX, App.FSpecific.FCurrentY)
  then
    if App.Controls.SetCurrent(App.FSpecific.FCurrentX, App.FSpecific.FCurrentY) then
    begin
      App.OnControlChange;
      App.ForceRedraw;

    end
    else
  else
    App.OnMouseButtonDown(App.FSpecific.FCurrentX, App.FSpecific.FCurrentY,
      App.FSpecific.FInputFlags);

  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOMOUSEUP }
function DoMouseUp(NextHandler: EventHandlerCallRef; TheEvent: EventRef;
  UserData: Pointer): OSStatus;
var
  WheresMyMouse: Carbon.Point;

  Modifier: UInt32;
  Button  : EventMouseButton;

  Sz : UInt32;
  App: Platform_support_ptr;
  Ept: EventParamType;

begin
  Ept := 0;

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamMouseLocation[1])
    ^), LongWord(PInt32(@TypeQDPoint[1])^), Ept, SizeOf(Carbon.Point), Sz,
    @WheresMyMouse);

  GlobalToLocal(WheresMyMouse);

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamKeyModifiers[1])^),
    LongWord(PInt32(@TypeUInt32[1])^), Ept, SizeOf(UInt32), Sz, @Modifier);

  App := Platform_support_ptr(UserData);

  App.FSpecific.FCurrentX := WheresMyMouse.H;

  if App._flip_y then
    App.FSpecific.FCurrentY := App.RbufWindow.GetHeight - WheresMyMouse.V
  else
    App.FSpecific.FCurrentY := WheresMyMouse.V;

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamMouseButton[1])^),
    LongWord(PInt32(@TypeMouseButton[1])^), Ept, SizeOf(EventMouseButton),
    Sz, @Button);

  case Button of
    KEventMouseButtonSecondary:
      App.FSpecific.FInputFlags := Mouse_right or Get_key_flags(Modifier);

  else
    App.FSpecific.FInputFlags := Mouse_left or Get_key_flags(Modifier);

  end;

  if App.Controls.OnMouseButtonUp(App.FSpecific.FCurrentX,
    App.FSpecific.FCurrentY) then
  begin
    App.OnControlChange;
    App.ForceRedraw;

  end;

  App.OnMouseButtonUp(App.FSpecific.FCurrentX, App.FSpecific.FCurrentY,
    App.FSpecific.FInputFlags);

  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOMOUSEDRAGGED }
function DoMouseDragged(NextHandler: EventHandlerCallRef; TheEvent: EventRef;
  UserData: Pointer): OSStatus;
var
  WheresMyMouse: Carbon.Point;

  Modifier: UInt32;
  Button  : EventMouseButton;

  Sz : UInt32;
  App: Platform_support_ptr;
  Ept: EventParamType;

begin
  Ept := 0;

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamMouseLocation[1])
    ^), LongWord(PInt32(@TypeQDPoint[1])^), Ept, SizeOf(Carbon.Point), Sz,
    @WheresMyMouse);

  GlobalToLocal(WheresMyMouse);
  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamKeyModifiers[1])^),
    LongWord(PInt32(@TypeUInt32[1])^), Ept, SizeOf(UInt32), Sz, @Modifier);

  App := Platform_support_ptr(UserData);

  App.FSpecific.FCurrentX := WheresMyMouse.H;

  if App._flip_y then
    App.FSpecific.FCurrentY := App.RbufWindow.GetHeight - WheresMyMouse.V
  else
    App.FSpecific.FCurrentY := WheresMyMouse.V;

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamMouseButton[1])^),
    LongWord(PInt32(@TypeMouseButton[1])^), Ept, SizeOf(EventMouseButton),
    Sz, @Button);

  case Button of
    KEventMouseButtonSecondary:
      App.FSpecific.FInputFlags := Mouse_right or Get_key_flags(Modifier);

  else
    App.FSpecific.FInputFlags := Mouse_left or Get_key_flags(Modifier);

  end;

  if App.Controls.OnMouseMove(App.FSpecific.FCurrentX, App.FSpecific.FCurrentY,
    App.FSpecific.FInputFlags and Mouse_left <> 0) then
  begin
    App.OnControlChange;
    App.ForceRedraw;

  end
  else
    App.OnMouseMove(App.FSpecific.FCurrentX, App.FSpecific.FCurrentY,
      App.FSpecific.FInputFlags);

  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOKEYDOWN }
function DoKeyDown(NextHandler: EventHandlerCallRef; TheEvent: EventRef;
  UserData: Pointer): OSStatus;
var
  Key_char          : Byte;
  Key_code, Modifier: UInt32;

  Sz : UInt32;
  App: Platform_support_ptr;
  Ept: EventParamType;

  Left, Up, Right, Down: Boolean;

begin
  Ept := 0;

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamKeyMacCharCodes[1])
    ^), LongWord(PInt32(@TypeChar[1])^), Ept, SizeOf(Byte), Sz, @Key_char);

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamKeyCode[1])^),
    LongWord(PInt32(@TypeUInt32[1])^), Ept, SizeOf(UInt32), Sz, @Key_code);

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamKeyModifiers[1])^),
    LongWord(PInt32(@TypeUInt32[1])^), Ept, SizeOf(UInt32), Sz, @Modifier);

  App := Platform_support_ptr(UserData);

  App.FSpecific.FLastTranslatedKey := 0;

  case Modifier of
    ControlKey:
      App.FSpecific.FInputFlags := App.FSpecific.FInputFlags or Kbd_ctrl;

    ShiftKey:
      App.FSpecific.FInputFlags := App.FSpecific.FInputFlags or Kbd_shift;

  else
    App.FSpecific.Translate(Key_char);

  end;

  case Key_char of
    KFunctionKeyCharCode:
      case Key_code of
        122:
          App.FSpecific.FLastTranslatedKey := Key_f1;
        120:
          App.FSpecific.FLastTranslatedKey := Key_f2;
        99:
          App.FSpecific.FLastTranslatedKey := Key_f3;
        118:
          App.FSpecific.FLastTranslatedKey := Key_f4;
        96:
          App.FSpecific.FLastTranslatedKey := Key_f5;
        97:
          App.FSpecific.FLastTranslatedKey := Key_f6;
        98:
          App.FSpecific.FLastTranslatedKey := Key_f7;
        100:
          App.FSpecific.FLastTranslatedKey := Key_f8;

      end;

  end;

  if (App.FSpecific.FLastTranslatedKey = 0) and (Key_char > 31) then
    App.FSpecific.FLastTranslatedKey := Key_char;

  if App.FSpecific.FLastTranslatedKey <> 0 then
  begin
    Left := False;
    Up := False;
    Right := False;
    Down := False;

    case App.FSpecific.FLastTranslatedKey of
      Key_left:
        Left := True;
      Key_up:
        Up := True;
      Key_right:
        Right := True;
      Key_down:
        Down := True;

      // On a Mac, screenshots are handled by the system.
      Key_f2:
        begin
          App.CopyWindowToImage(Max_images - 1);
          App.Save_img(Max_images - 1, 'screenshot.png');

        end;

      Key_f4:
        if Modifier = OptionKey then
          App.Quit;

    end;

    if App.Controls.OnArrowKeys(Left, Right, Down, Up) then
    begin
      App.OnControlChange;
      App.ForceRedraw;

    end
    else
      App.OnKey(App.FSpecific.FCurrentX, App.FSpecific.FCurrentY,
        App.FSpecific.FLastTranslatedKey, App.FSpecific.FInputFlags);

  end;

  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOKEYUP }
function DoKeyUp(NextHandler: EventHandlerCallRef; TheEvent: EventRef;
  UserData: Pointer): OSStatus;
var
  Key_code: Byte;
  Modifier: UInt32;

  Sz : UInt32;
  App: Platform_support_ptr;
  Ept: EventParamType;

begin
  Ept := 0;

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamKeyMacCharCodes[1])
    ^), LongWord(PInt32(@TypeChar[1])^), Ept, SizeOf(Byte), Sz, @Key_code);

  GetEventParameter(TheEvent, LongWord(PInt32(@KEventParamKeyModifiers[1])^),
    LongWord(PInt32(@TypeUInt32[1])^), Ept, SizeOf(UInt32), Sz, @Modifier);

  App := Platform_support_ptr(UserData);

  App.FSpecific.FLastTranslatedKey := 0;

  case Modifier of
    ControlKey:
      App.FSpecific.FInputFlags := App.FSpecific.FInputFlags and
        not Kbd_ctrl;

    ShiftKey:
      App.FSpecific.FInputFlags := App.FSpecific.FInputFlags and
        not Kbd_shift;

  end;

  Result := CallNextEventHandler(NextHandler, TheEvent);

end;

{ DOPERIODICTASK }
procedure DoPeriodicTask(TheTimer: EventLoopTimerRef; UserData: Pointer);
var
  App: Platform_support_ptr;

begin
  App := Platform_support_ptr(UserData);

  if not App._wait_mode then
    App.OnIdle;

end;

{ INIT }
function Platform_support.Init;
var
  EventType  : EventTypeSpec;
  HandlerUPP : EventHandlerUPP;
  TheTarget  : CFStringRef;
  WindowAttrs: WindowAttributes;
  Bounds     : Carbon.Rect;
  MainLoop   : EventLoopRef;
  TimerUPP   : EventLoopTimerUPP;
  TheTimer   : EventLoopTimerRef;

begin
  if FSpecific.FSystemPixelFormat = pfUndefined then
  begin
    Result := False;

    Exit;

  end;

  FWindowFlags := Flags;

  // application
  TheTarget := GetApplicationEventTarget;

  EventType.EventClass := LongWord(PInt32(@KEventClassApplication[1])^);
  EventType.EventKind := KEventAppQuit;

  HandlerUPP := NewEventHandlerUPP(@DoAppQuit);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, nil, nil);

  EventType.EventClass := LongWord(PInt32(@KEventClassMouse[1])^);
  EventType.EventKind := KEventMouseDown;

  HandlerUPP := NewEventHandlerUPP(@DoMouseDown);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  EventType.EventKind := KEventMouseUp;

  HandlerUPP := NewEventHandlerUPP(@DoMouseUp);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  EventType.EventKind := KEventMouseDragged;

  HandlerUPP := NewEventHandlerUPP(@DoMouseDragged);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  EventType.EventClass := LongWord(PInt32(@KEventClassKeyboard[1])^);
  EventType.EventKind := KEventRawKeyDown;

  HandlerUPP := NewEventHandlerUPP(@DoKeyDown);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  EventType.EventKind := KEventRawKeyUp;

  HandlerUPP := NewEventHandlerUPP(@DoKeyUp);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  EventType.EventKind := KEventRawKeyRepeat;

  HandlerUPP := NewEventHandlerUPP(@DoKeyDown);
  // 'key repeat' is translated to 'key down'

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  // window
  WindowAttrs := KWindowCloseBoxAttribute or KWindowCollapseBoxAttribute or
    KWindowStandardHandlerAttribute;

  if Flags and wfResize <> 0 then
    WindowAttrs := WindowAttrs or KWindowResizableAttribute or
      KWindowFullZoomAttribute or KWindowLiveResizeAttribute;

  SetRect(Bounds, 0, 0, Width_, Height_);
  OffsetRect(Bounds, 100, 100);

  CreateNewWindow(KDocumentWindowClass, WindowAttrs, Bounds,
    FSpecific.FWindow);

  if FSpecific.FWindow = nil then
  begin
    Result := False;

    Exit;

  end;

  // I assume the text is ASCII.
  // Change to kCFStringEncodingMacRoman, kCFStringEncodingISOLatin1, kCFStringEncodingUTF8 or what else you need.
  SetWindowTitleWithCFString(FSpecific.FWindow,
    CFStringCreateWithPascalStringNoCopy(nil, FCaption,
    KCFStringEncodingASCII, nil));

  TheTarget := GetWindowEventTarget(FSpecific.FWindow);

  EventType.EventClass := LongWord(PInt32(@KEventClassWindow[1])^);
  EventType.EventKind := KEventWindowClose;

  HandlerUPP := NewEventHandlerUPP(@DoWindowClose);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  EventType.EventKind := KEventWindowDrawContent;

  HandlerUPP := NewEventHandlerUPP(@DoWindowDrawContent);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  EventType.EventKind := KEventWindowBoundsChanged;

  HandlerUPP := NewEventHandlerUPP(@DoWindowResize);

  InstallEventHandler(TheTarget, HandlerUPP, 1, EventType, @Self, nil);

  // Periodic task
  // Instead of an idle function I use the Carbon event timer.
  // You may decide to change the wait value which is currently 50 milliseconds.
  MainLoop := GetMainEventLoop;
  TimerUPP := NewEventLoopTimerUPP(@DoPeriodicTask);

  InstallEventLoopTimer(MainLoop, 0, 50 * KEventDurationMillisecond, TimerUPP,
    @Self, TheTimer);

  FSpecific.Create_pmap(Width_, Height_, @FRenderingBuffer_window);

  FInitialWidth := Width_;
  FInitialHeight := Height_;

  OnInit;
  OnResize(Width_, Height_);

  FSpecific.FRedrawFlag := True;

  ShowWindow(FSpecific.FWindow);
  SetPortWindowPort(FSpecific.FWindow);

  Result := True;

end;

{ RUN }
function Platform_support.Run;
begin
  RunApplicationEventLoop;

  Result := 1;

end;

{ QUIT }
procedure Platform_support.Quit;
begin
  QuitApplicationEventLoop;

end;

{ _FORMAT }
function Platform_support._format;
begin
  Result := FPixelFormat;

end;

{ _FLIP_Y }
function Platform_support._flip_y;
begin
  Result := FFlipY;

end;

{ _BPP }
function Platform_support.GetBitsPerPixel;
begin
  Result := FBitsPerPixel;

end;

{ _WAIT_MODE }
function Platform_support._wait_mode;
begin
  Result := FWaitMode;

end;

{ SetWaitMode }
procedure Platform_support.SetWaitMode;
begin
  FWaitMode := Wait_mode;

end;

{ FORCE_REDRAW }
procedure Platform_support.ForceRedraw;
var
  Bounds: Carbon.Rect;

begin
  FSpecific.FRedrawFlag := True;

  // OnControlChange
  OnDraw;

  SetRect(Bounds, 0, 0, FRenderingBuffer_window.GetWidth, FRenderingBuffer_window.GetHeight);
  InvalWindowRect(FSpecific.FWindow, Bounds);

end;

{ UPDATE_WINDOW }
procedure Platform_support.UpdateWindow;
begin
  FSpecific.Display_pmap(FSpecific.FWindow, @FRenderingBuffer_window);

end;

{ RbufWindow }
function Platform_support.RbufWindow;
begin
  Result := @FRenderingBuffer_window;

end;

{ RbufImage }
function Platform_support.RbufImage;
begin
  Result := @FRenderingBuffer_img[Idx];

end;

{ _IMG_EXT }
function Platform_support.GetImageExtension;
begin
  Result := '.bmp';

end;

{ CopyImageToWindow }
procedure Platform_support.CopyImageToWindow;
begin
  if (Idx < Max_images) and (RbufImage(Idx).GetBuffer <> nil) then
    RbufWindow.CopyFrom(RbufImage(Idx));

end;

{ CopyWindowToImage }
procedure Platform_support.CopyWindowToImage;
begin
  if Idx < Max_images then
  begin
    CreateImage(Idx, RbufWindow.GetWidth, RbufWindow.GetHeight);
    RbufImage(Idx).CopyFrom(RbufWindow);

  end;

end;

{ CopyImageToImage }
procedure Platform_support.CopyImageToImage;
begin
  if (Idx_from < Max_images) and (Idx_to < Max_images) and
    (RbufImage(Idx_from).GetBuffer <> nil) then
  begin
    CreateImage(Idx_to, RbufImage(Idx_from).GetWidth, RbufImage(Idx_from).GetHeight);

    RbufImage(Idx_to).CopyFrom(RbufImage(Idx_from));

  end;

end;

{ OnInit }
procedure Platform_support.OnInit;
begin
end;

{ OnResize }
procedure Platform_support.OnResize;
begin
end;

{ OnIdle }
procedure Platform_support.OnIdle;
begin
end;

{ ON_MOUSE_MOVE }
procedure Platform_support.OnMouseMove;
begin
end;

{ ON_MOUSE_ButtonDown }
procedure Platform_support.OnMouseButtonDown;
begin
end;

{ ON_MOUSE_ButtonUp }
procedure Platform_support.OnMouseButtonUp;
begin
end;

{ OnKey }
procedure Platform_support.OnKey;
begin
end;

{ OnControlChange }
procedure Platform_support.OnControlChange;
begin
end;

{ OnDraw }
procedure Platform_support.OnDraw;
begin
end;

{ OnPostDraw }
procedure Platform_support.OnPostDraw;
begin
end;

{ ADD_CTRL }
procedure Platform_support.Add_ctrl;
begin
  Controls.Add(C);

  C.Transform(@FResizeMatrix);

end;

{ TRANS_AFFINE_RESIZING_ }
procedure Platform_support.Trans_affine_resizing_;
var
  Vp: Trans_viewport;
  Ts: Trans_affine_scaling;

begin
  if FWindowFlags and wfKeepAspectRatio <> 0 then
  begin
    // double sx = double(width) / double(FInitialWidth);
    // double sy = double(height) / double(FInitialHeight);
    // if(sy < sx) sx = sy;
    // FResizeMatrix = trans_affine_scaling(sx, sx);

    Vp.Create;
    Vp.PreserveAspectRatio(0.5, 0.5, arMeet);

    Vp.DeviceViewport(0, 0, Width_, Height_);
    Vp.WorldViewport(0, 0, FInitialWidth, FInitialHeight);

    Vp.ToAffine(@FResizeMatrix);

  end
  else
  begin
    Ts.Create(Width_ / FInitialWidth, Height_ / FInitialHeight);

    FResizeMatrix.Assign(@Ts);

  end;

end;

{ GetTransAffineResizing }
function Platform_support.GetTransAffineResizing;
begin
  Result := @FResizeMatrix;

end;

{ GetWidth }
function Platform_support.GetWidth;
begin
  Result := FRenderingBuffer_window.GetWidth;

end;

{ _HEIGHT }
function Platform_support.GetHeight;
begin
  Result := FRenderingBuffer_window.GetHeight;

end;

{ _INITIAL_WIDTH }
function Platform_support.Initial_width;
begin
  Result := FInitialWidth;
end;

{ _INITIAL_HEIGHT }
function Platform_support.Initial_height;
begin
  Result := FInitialHeight;
end;

{ GetWindowFlags }
function Platform_support.GetWindowFlags;
begin
  Result := FWindowFlags;
end;

{ GetRawDisplayHandler }
function Platform_support.GetRawDisplayHandler;
begin
end;

{ DisplayMessage }
procedure Platform_support.DisplayMessage;
var
  Dlg: DialogRef;
  Itm: DialogItemIndex;
begin
  CreateStandardAlert(KAlertPlainAlert, CFStringCreateWithCStringNoCopy(nil,
    'AGG Message', KCFStringEncodingASCII, nil),
    CFStringCreateWithCStringNoCopy(nil, Msg, KCFStringEncodingASCII, nil),
    nil, Dlg);

  RunStandardAlert(Dlg, nil, Itm);
end;

{ START_TIMER }
procedure Platform_support.StartTimer;
begin
  Microseconds(FSpecific.FSwStart);

end;

{ GetElapsedTime }
function Platform_support.Elapsed_time;
var
  Stop: CardinalWide;

begin
  Microseconds(Stop);

  Result := (Stop.Lo - FSpecific.FSwStart.Lo) * 1E6 /
    FSpecific.FSwFreq.Lo;

end;

{ FULL_FILE_NAME }
function Platform_support.Full_file_name;
begin
  Result := File_name;

end;

{ FILE_SOURCE }
function Platform_support.File_source;
begin
  Result := Fname;

end;

end.
